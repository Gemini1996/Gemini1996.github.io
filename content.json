{"meta":{"title":"Gemini1996的博客","subtitle":null,"description":null,"author":"Gemini1996","url":"https://github.com/Gemini1996"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2018-12-23T00:45:07.030Z","updated":"2018-12-23T00:45:07.030Z","comments":true,"path":"2018/12/23/hello-world/","link":"","permalink":"https://github.com/Gemini1996/2018/12/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"let和const命令","slug":"let和const命令","date":"2018-12-22T16:00:00.000Z","updated":"2018-12-23T10:52:37.539Z","comments":true,"path":"2018/12/23/let和const命令/","link":"","permalink":"https://github.com/Gemini1996/2018/12/23/let和const命令/","excerpt":"ES6新增的let和const命令","text":"ES6新增的let和const命令 1、let命令基本用法let命令，用来声明变量。用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 for循环的计数器，就很合适使用let命令。1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。let命令所声明的变量一定要在声明后使用，否则报错1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区（temporal dead zone，简称TDZ）只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。 不能重复声明let不允许在相同作用域内，重复声明同一个变量。1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 2、块级作用域ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。内层变量可能会覆盖外层变量12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'hello world'; &#125;&#125;f(); // undefined 用来计数的循环变量泄露为全局变量1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 let实际上为 JavaScript 新增了块级作用域。1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; ES6 允许块级作用域的任意嵌套。1&#123;&#123;&#123;&#123;&#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 块级作用域与函数声明ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。1234567891011function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。123456789// ES5 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; function f() &#123; console.log('I am inside!'); &#125; if (false) &#123; &#125; f();&#125;()); ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。12345678910// 不报错'use strict';if (true) &#123; function f() &#123;&#125;&#125;// 报错'use strict';if (true) function f() &#123;&#125; 3、const命令基本语法const声明一个只读的常量。一旦声明，常量的值就不能改变const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。12const foo;// SyntaxError: Missing initializer in const declaration const的作用域与let命令相同：只在声明所在的块级作用域内有效。const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: \"foo\" is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 4、顶级对象的属性顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。12345window.a = 1;a // 1a = 2;window.a // 2 ES6一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined","categories":[{"name":"ES6","slug":"ES6","permalink":"https://github.com/Gemini1996/categories/ES6/"}],"tags":[{"name":"let","slug":"let","permalink":"https://github.com/Gemini1996/tags/let/"},{"name":"const","slug":"const","permalink":"https://github.com/Gemini1996/tags/const/"},{"name":"ES6","slug":"ES6","permalink":"https://github.com/Gemini1996/tags/ES6/"}]}]}